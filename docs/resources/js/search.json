[[{"l":"Overview","p":["CollQL is a Dart library inspired by MongoDB queries, designed for expressive and flexible in-memory collection manipulation and filtering.","Filters: Create complex queries using logical and comparison operators.","Modifiers: Update collections and documents with MongoDB-like operations.","Extensions: Utility methods to simplify usage with Dart collections.","Proxies: Builders for fluent construction of filters and modifiers."]},{"l":"Quick Guide"},{"l":"Documents","p":["These are the basic data structure in CollQL. Each document is represented by an object containing key-value pairs, similar to a map or JSON object. [Read more]"]},{"l":"Filters","p":["Allow you to select documents from a collection or test values based on conditions. They are inspired by MongoDB operators. [Read more]","Some operators: eq, notEq, gt, gte, lt, lte, and, or"]},{"l":"Modifiers","p":["Allow you to update documents declaratively. [Read more]","Some modifiers: get, set, unset, rename, push, pull"]},{"l":"Credits","p":["CollQL is inspired by Nitrite, and combines concepts from both MongoDB and Dart's collection manipulation capabilities. It aims to provide a seamless and expressive way to work with in-memory data structures."]}],[{"l":"Documents","p":["CollQL works with information organized into entities known as Document s. Each Document is structured as key-value pairs, similar to a JavaScript JSON or a Dart MapString, dynamic.","Consider the following document example:","In a Document, each property key must always be a non-null, non-empty String and cannot contain the sub-document wildcard delimiter. Every Document has a unique identifier, which can be provided or generated automatically. By default, the unique identifier is stored in the id property, but you can specify a different location using idPath.","Document is a very simple and flexible class, you can easily create your own implementation. Review the abstraction (/lib/abstractions/document.dart) and the default implementation (/lib/implementations/document.dart) to understand how it works.","In the following documentation, we will review the default behavior provided by Document."]},{"l":"Automatically generating a unique document identifier","p":["In the default implementation, Document uses UUID V4 as the unique identifier."]},{"l":"Reading and writing properties","p":["To access or modify document properties, you can use the get and set methods. In the default implementation, you can use JSON Pointer for access.","If you wish, you can implement a custom property access version, for example, using . as a separator instead of JSON Pointer.","To remove a field, you can use the remove method."]},{"l":"Validating properties","p":["You can validate document properties using the validate method, which accepts a path and a validation model reference. In the default implementation, the model is defined as a JSON Schema."]},{"l":"Document methods","p":["_","add(path, value)","Alias for set, with the same functionality.","Converts the document to a JSON map.","Converts the document's internal map to a JSON map MapString, dynamic using Dart's jsonEncode.","Copies attributes from a document to the specified location.","Copies the value from one property to another.","copy(pathSource, pathTarget)","Default implementation","Description","diff(path, Document)","generateId()","Generates a unique identifier for the document.","get(path)","Gets the difference between a property and a document.","Gets the document's property keys.","Gets the type of the specified property.","Gets the unique identifier of the document.","Gets the value of the specified property.","getType(path)","id","JSON Pointer","JSON Pointer + JSON Schema","jsonEncode","keys","mergePatch(path, Document)","Method","move(pathSource, pathTarget)","Moves the value from one property to another.","remove(path)","Removes the specified property.","Returns information about the document size, number of properties, and estimated memory size {paths: length, bytes: 400}.","Returns the document's internal map MapString, dynamic.","set(path, value)","Sets the value of the specified property.","sizeInfo()","toJson()","toJsonString()","toMap()","UUID V4","validate(path, Reference)","Validates the specified property against a reference model."]},{"l":"Collections","p":["Collections are groups of documents that provide a way to organize and manage related documents. In CollQL, collections are represented by CollectionQl objects.","You can perform operations on collections, such as filters [Read More] and modifiers [Read more]."]}],[{"l":"Introduction","p":["Filters are used to test criteria on a document or a collection. They provide a way to specify the conditions that documents must meet to be included in the result set. Each filtering criterion is based on a property in the document and an assertion test."]},{"l":"Fluent Language","p":["CollQL is based on a fluent query language. It provides a global where method to start creating a filter. The where method takes the name of a field as an input parameter and returns a Filter object. The Filter object provides several methods to create different types of filters. Here is an example:","The code above creates a filter for the name property, then applies an equality test. The apply method will return true if the value of the name property in the document is equal to \"John\".","CollQL provides a String extension to create access facilitators for filters. It creates a filter based on the property name specified in the String. Changing the example above, we can use the String extension to create the filter:","A third alternative is operator overloading to create filters. It creates a filter for the property name specified in the String. Example:","Valid operators in the Filter String extension.","Operator","Description","Greater than filter","=","Greater than or equal filter","Less than filter","Less than or equal filter"]},{"l":"Filter Types","p":["CollQL filters can be grouped into the following categories:","Logical filters","Comparison filters"]},{"l":"Logical Filters","p":["Logical filters are used to combine multiple filters into a single filter. The following logical filters are supported:","Operator","Description","and or","Matches all documents that meet all specified filters.","or or |","Matches all documents that meet at least one of the specified filters.","not or ~","Matches all documents that do not meet the specified filter.","The following example shows some ways to use a logical filter:","Querying through a list of criteria allows you to combine more than two filtering criteria. The chained format hierarchizes the criteria.","(name == 'John' and age 18 and city == 'New York')","(name == 'John' and (age 18 and city == 'New York'))"]},{"l":"Comparison Filters","p":["Comparison filters are used to compare a property with a value. The following comparison filters are available:","Description","eq","gt","gte","lt","lte","Matches all documents where the property value is different from all values specified in a list.","Matches all documents where the property value is equal to the specified value.","Matches all documents where the property value is greater than or equal to the specified value.","Matches all documents where the property value is greater than the specified value.","Matches all documents where the property value is less than or equal to the specified value.","Matches all documents where the property value is less than the specified value.","Matches all documents where the property value is within a specified list.","Matches all documents where the property value matches a specified regular expression.","notin","Operator","regex","Usage examples:","within"]},{"l":"Extending Filters","p":["You can extend filters to add new methods or functionalities. For example, you can create a custom filter that checks if a property is between specific values:"]},{"l":"Creating the Filter","p":["To create a custom filter, you can extend the Filter class and add the desired method, or extend from an existing filter type. Here is an example of how to create a between filter:"]},{"l":"Extending Access Facilitators","p":["To add the new between filter as an access facilitator, you can extend the String class and add the desired method. Here is an example of how to do this:"]}],[{"l":"Introduction","p":["Modifiers are used to update documents declaratively, allowing operations similar to those in MongoDB. They can be applied to individual documents or entire collections.","Modifiers can also be used in a fluent writing style. Read more."]},{"l":"Setters vs Modifiers","p":["Modifiers work as a set of instructions that describe how data should be changed, without the need to specify a particular document.","The setter acts directly on the property of a single document, while the modifier describes the transformation that should be applied in the future to a document or a collection, and can also be combined with filters."]},{"l":"Types of modifiers","p":["CollQL modifiers can be grouped into the following categories:","Value modifiers","List modifiers","Conditional modifiers"]},{"l":"Value modifiers","p":["Value modifiers are used to change the value of a property. The following value modifiers are supported:","Operator","Description","set","Changes the value of a property.","currentDate","Sets the value of a property to the current date/time.","inc","Increments the value of a property by the specified amount.","mul","Multiplies the value of a property by the specified amount.","rename","Renames a property.","unset","Removes a property and its value."]},{"l":"List modifiers","p":["List modifiers are used to manipulate lists in a property. The following list modifiers are supported:","Operator","Description","addToSet","Adds a value to the end of a list if it is not already present.","pop","Removes the value from a list at the indicated position. If no position is indicated, removes the last value from the list.","pull","Removes values from a list that match a predicate.","push","Adds a value to a list at the indicated position. If no position is indicated, adds to the end of the list.","sort","Sorts the elements of a list."]},{"l":"Conditional modifiers","p":["Conditional modifiers are used to change the value of a property based on a condition. The following conditional modifiers are supported:","Operator","Description","max","Sets the value of a property to the specified value if the specified value is greater than the current value.","min","Sets the value of a property to the specified value if the specified value is less than the current value.","Usage examples:"]},{"l":"Extending modifiers","p":["You can create your own modifiers by extending the Modifier class. This allows you to add new functionality or modify the behavior of existing modifiers. See Extending Filters for an idea of how to create new modifiers."]}]]